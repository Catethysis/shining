<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="module">
			import * as THREE from './three.module.js';
			import Stats from './stats.module.js';
			import { STLLoader } from './STLLoader.js';
            import { VertexNormalsHelper } from './VertexNormalsHelper.js';
			let container, stats, camera, cameraTarget, scene, renderer;

            let raycaster = 0;
            let mouse = 0;
			init();
			animate();

			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				// camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 15);
				// camera.position.set(3, 0.15, 3);
				// cameraTarget = new THREE.Vector3(0, -0.25, 0);

				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 15);
				camera.position.set(10, 0, 0);
				cameraTarget = new THREE.Vector3(0, 0, 0);
                
                // camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
                // camera.position.set( 0, 0, 100 );
                // camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x72645b);
				scene.fog = new THREE.Fog(0x72645b, 2, 15);

				// Ground
				const plane = new THREE.Mesh(
					new THREE.PlaneGeometry(40, 40),
					new THREE.MeshPhongMaterial({ color: 0x999999, specular: 0x101010 })
				);
				plane.rotation.x = -Math.PI / 2;
				plane.position.y = -0.5;
				scene.add(plane);

				plane.receiveShadow = true;

				// ASCII file
                var obj_geometry = 0;
                var normalMatrix = 0;
				const loader = new STLLoader();
				loader.load('./block.stl', function (geometry) {
                    obj_geometry = geometry;
					var material = new THREE.MeshPhongMaterial({color: 0xff5533, specular: 0x111111, shininess: 200, opacity: 0.5,
    transparent: true});
                    material.side = THREE.DoubleSide
					const mesh = new THREE.Mesh(geometry, material);

                    //
					mesh.position.set(-0.3, 0, 0);
					mesh.rotation.set(-Math.PI / 2, 0, 0);

					// mesh.position.set(0, -0.25, 0.6);
					mesh.position.set(-0.3, 0, 0);
					// mesh.rotation.set(0, -Math.PI / 2, 0);
					mesh.rotation.set(-Math.PI / 2, 0, 0);
					// mesh.scale.set(0.5, 0.5, 0.5);

					mesh.castShadow = true;
					mesh.receiveShadow = true;

                    // make object system
                    mesh.updateMatrixWorld();
                    normalMatrix = new THREE.Matrix3().getNormalMatrix( mesh.matrixWorld );

                    console.log(scene.children)
					scene.add(mesh);
                    console.log(scene.children)
                    // var vnh = new VertexNormalsHelper( mesh, 1, 0xff0000 );
                    // scene.add( vnh );
				});

				// Lights
				scene.add(new THREE.HemisphereLight(0x443333, 0x111122));

				addShadowedLight(1, 1, 1, 0xffffff, 1.35);
				addShadowedLight(0.5, 1, -1, 0xffaa00, 1);

                // renderer
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.outputEncoding = THREE.sRGBEncoding;

				renderer.shadowMap.enabled = true;

				container.appendChild(renderer.domElement);

				// // stats
				// stats = new Stats();
				// container.appendChild(stats.dom);

				window.addEventListener('resize', onWindowResize);

                const raycaster = new THREE.Raycaster();
                const fire_step = ({pos, d, medium}) => {
                    raycaster.set(pos, d)
                    const intersect = raycaster.intersectObject(scene.children[4])
                    if (intersect[0]) {
                        pos = intersect[0].point
                        let u = 1/1.3
                        console.log(intersect[0])
                        let n = intersect[0].face.normal.clone().applyMatrix3( normalMatrix ).normalize();
                        let r = d.clone().reflect(n)
                        if(medium) {
                            u = 1/u;
                            n = n.negate()
                        }
                        let nd = n.clone().cross(d)
                        let t = n.clone().cross(n.clone().negate().cross(d)).multiplyScalar(u).
                            sub(n.clone().multiplyScalar(Math.sqrt(1-u*u*nd.lengthSq())))
                        let delta = 0.0001
                        pos.add(t.clone().multiplyScalar(delta))
                        return {pos, t, r, energy_t: 1, energy_r: 1, medium: 1 - medium}
                    }
                }

                const fire = (pos, ray) => {
                    console.log(pos, ray)
                    let out1 = fire_step({pos, d: ray.clone().normalize(), medium: 0})
                    let out2 = fire_step({pos: out1.pos, d: out1.t, medium: out1.medium})
                    // let out3 = fire_step({pos: out2.pos, d: out2.t, medium: out2.medium})

                    const linematerial = new THREE.LineBasicMaterial({color: 0x0000ff});
                    const linepoints = [];
                    linepoints.push(pos);
                    linepoints.push(out1.pos);
                    linepoints.push(out2.pos);
                    linepoints.push(out2.pos.clone().add(out2.t.clone().setLength(0.3)));
                    const linegeometry = new THREE.BufferGeometry().setFromPoints(linepoints);
                    const line = new THREE.Line(linegeometry, linematerial);
                    scene.add(line);
                }

                let d = 1;
                setInterval(() => {
                    if(d > -1) {
                        fire(new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 1, d))
                        d -= 0.1
                    }
                }, 10);
			}

			function addShadowedLight(x, y, z, color, intensity) {
				const directionalLight = new THREE.DirectionalLight(color, intensity);
				directionalLight.position.set(x, y, z);
				scene.add(directionalLight);

				directionalLight.castShadow = true;

				const d = 1;
				directionalLight.shadow.camera.left   = -d;
				directionalLight.shadow.camera.right  =  d;
				directionalLight.shadow.camera.top    =  d;
				directionalLight.shadow.camera.bottom = -d;
				directionalLight.shadow.camera.near   =  1;
				directionalLight.shadow.camera.far    =  4;
				directionalLight.shadow.bias = -0.002;
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);

				render();
				// stats.update();
			}

			function render() {
				const timer = Date.now() * 0.00;

				camera.position.x = Math.cos(timer) * 3;
				camera.position.z = Math.sin(timer) * 3;
				camera.lookAt(cameraTarget);

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>