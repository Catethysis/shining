<!DOCTYPE html>
<html lang="en">
	<head>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<script type="module">
			import * as THREE from 'threejs/three.module.js';
			import Stats from 'threejs/stats.module.js';
			import { STLLoader } from 'threejs/STLLoader.js';
			import { VertexNormalsHelper } from 'threejs/VertexNormalsHelper.js';
			import { OrbitControls } from 'threejs/OrbitControls.js'
			let container, stats, camera, cameraTarget, scene, renderer;

			let raycaster = 0;
			let mouse = 0;
			init();
			animate();

			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				// camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 15);
				// camera.position.set(3, 0.15, 3);
				// cameraTarget = new THREE.Vector3(0, -0.25, 0);

				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 15);
				camera.position.set(10, 0.6, -0.7);
				cameraTarget = new THREE.Vector3(0, 0.6, -0.7);
				let controls = new OrbitControls( camera, container );
				// controls.minPolarAngle = 0;
				// controls.maxPolarAngle = Math.PI;
				// controls.minAzimuthAngle = 0;
				// controls.maxAzimuthAngle = Math.PI;
				
				// camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500 );
				// camera.position.set( 0, 0, 100 );
				// camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x72645b);
				scene.fog = new THREE.Fog(0x72645b, 2, 15);

				// Ground
				const plane = new THREE.Mesh(
					new THREE.PlaneGeometry(40, 40),
					new THREE.MeshPhongMaterial({ color: 0x999999, specular: 0x101010 })
				);
				plane.rotation.x = -Math.PI / 2;
				plane.position.y = -0.5;
				scene.add(plane);

				plane.receiveShadow = true;
				const model = 6, models = ['./block.stl', './lens.stl', './lens2.stl', './2lens.stl', './condenser.stl',
					'./lightguide.stl', './pipe.stl']

				// ASCII file
				var obj_geometry = 0;
				var normalMatrix = 0;
				const loader = new STLLoader();
				loader.load(models[model], function (geometry) {
					obj_geometry = geometry;
					var material = new THREE.MeshPhongMaterial({color: 0xff5533, specular: 0x111111, shininess: 200, opacity: 0.5,
	transparent: true});
					material.side = THREE.DoubleSide
					const mesh = new THREE.Mesh(geometry, material);

					switch (model) {
						case 0: // block
								mesh.position.set(-0.3, 0, 0);
								mesh.rotation.set(-Math.PI / 2, 0, 0);
								break;
						case 1: // lens
								mesh.position.set(-0.2, 0, 0);
								mesh.rotation.set(-Math.PI / 2, 0, 0);
								mesh.scale.set(0.1, 0.1, 0.1);
								break;
						case 2: // lens2
								mesh.position.set(-0.2, 0, 0);
								mesh.rotation.set(-Math.PI / 2, 0, 0);
								mesh.scale.set(0.1, 0.1, 0.1);
								break;
						case 3: // 2lens
								mesh.position.set(-0.2, 0, 0);
								mesh.rotation.set(-Math.PI / 2, 0, 0);
								mesh.scale.set(0.1, 0.1, 0.1);
								break;
						case 4: // condenser
								mesh.position.set(-0.2, 0, 0);
								mesh.rotation.set(-Math.PI / 2, 0, 0);
								mesh.scale.set(0.1, 0.1, 0.1);
								break;
						case 5: // lightguide
								mesh.position.set(-0.2, 10, 0.5);
								mesh.rotation.set(-Math.PI / 2, 0, 0);
								mesh.scale.set(0.1, 0.1, 0.1);
								break;
						case 6: // pipe
								mesh.position.set(0.2, -0.1, 0.1);
								mesh.rotation.set(-Math.PI / 2, 0, Math.PI / 2);
								mesh.scale.set(0.45, 0.45, 0.45);
								break;
					}

					mesh.castShadow = true;
					mesh.receiveShadow = true;
					mesh.layers.enable(1)

					// make object system
					mesh.updateMatrixWorld();
					normalMatrix = new THREE.Matrix3().getNormalMatrix( mesh.matrixWorld );

					scene.add(mesh);
					// var vnh = new VertexNormalsHelper( mesh, 1, 0xff0000 );
					// scene.add( vnh );
				});

				// Lights
				scene.add(new THREE.HemisphereLight(0x443333, 0x111122));

				addShadowedLight(1, 1, 1, 0xffffff, 1.35);
				addShadowedLight(0.5, 1, -1, 0xffaa00, 1);

				// renderer
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.outputEncoding = THREE.sRGBEncoding;

				renderer.shadowMap.enabled = true;

				container.appendChild(renderer.domElement);
				window.addEventListener('resize', onWindowResize);

				const raycaster = new THREE.Raycaster();
				raycaster.layers.set(1);

				const draw_line = (points, end) => {
					const linematerial = new THREE.LineBasicMaterial({color: end ? 0xff0000 : 0x0000ff});
					const linegeometry = new THREE.BufferGeometry().setFromPoints(points);
					const line = new THREE.Line(linegeometry, linematerial);
					scene.add(line);
				}

				const fire_step = ({pos, d, medium, depth}) => {
					console.log("===========================", medium, depth)
					raycaster.set(pos, d.normalize())
					console.log(pos, d.normalize())
					const intersect = raycaster.intersectObjects(scene.children)
					console.log(intersect[0])
					let collide = 0
					if (intersect[0])
						collide = intersect[0].point
					
					console.log([pos.clone(), collide])
					if(collide) draw_line([pos.clone(), collide], 0)
					else draw_line([pos.clone(), pos.clone().add(d.clone().setLength(0.3))], 1)

					if(collide) {
						let u = 1/1.3
						let n = intersect[0].face.normal.clone().applyMatrix3( normalMatrix ).normalize();
						// let r = d.clone().reflect(n.negate())
						let r = d.clone().add(n.multiplyScalar(-2*d.dot(n)))
						if(medium) {
							u = 1/u;
							n = n.negate()
						}
						let nd = n.clone().cross(d)
						let t = n.clone().cross(nd).multiplyScalar(-u).sub(n.clone().multiplyScalar(Math.sqrt(1 - u*u*nd.lengthSq())))

						const delta = 0.001
						if(depth > 1) {
							console.log(t, r)
							if(!isNaN(t.x)) fire_step({pos: collide.clone().add(t.clone().multiplyScalar(delta)), d: t, medium: 1 - medium, depth: depth - 1})
							if(!isNaN(r.x)) fire_step({pos: collide.clone().add(r.clone().multiplyScalar(delta)), d: r, medium:     medium, depth: depth - 1})
						}
					}
				}

				setTimeout(() => {
					draw_line([new THREE.Vector3(0,0,0), new THREE.Vector3(0.3,0,0)])
					draw_line([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0.1,0)])
					draw_line([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0.2)])
					let d = -0.8
					// for(d = -0.8; d < 0.2; d += 0.1)
						fire_step({pos: new THREE.Vector3(0, -0.5, 0), d: new THREE.Vector3(0, 1, d), medium: 0, depth: 6})
				}, 100)
			}

			function addShadowedLight(x, y, z, color, intensity) {
				const directionalLight = new THREE.DirectionalLight(color, intensity);
				directionalLight.position.set(x, y, z);
				scene.add(directionalLight);

				directionalLight.castShadow = true;

				const d = 1;
				directionalLight.shadow.camera.left   = -d;
				directionalLight.shadow.camera.right  =  d;
				directionalLight.shadow.camera.top    =  d;
				directionalLight.shadow.camera.bottom = -d;
				directionalLight.shadow.camera.near   =  1;
				directionalLight.shadow.camera.far    =  4;
				directionalLight.shadow.bias = -0.002;
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);

				render();
				// stats.update();
			}

			function render() {
				const timer = Date.now() * 0.00;

				camera.position.x = Math.cos(timer) * 3;
				camera.position.z = Math.sin(timer) * 3;
				camera.lookAt(cameraTarget);

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>